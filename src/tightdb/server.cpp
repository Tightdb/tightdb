#include <stdint.h>
#include <cstring>
#include <algorithm>
#include <stdexcept>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <string>
#include <sstream>

#include <tightdb/util/bind.hpp>
#include <tightdb/util/unique_ptr.hpp>
#include <tightdb/util/memory_stream.hpp>
#include <tightdb/util/logger.hpp>
#include <tightdb/util/network.hpp>
#include <tightdb/string_data.hpp>
#include <tightdb/binary_data.hpp>


// Client --> server
// -----------------
//
//   head  =  'ident'  <session ident>  <path size>
//   body  =  <path>
//
//       Where <session ident> is a session identifier generated by the
//       client. A session identifier is a non-zero positive integer stricly
//       less than 2**16. Sessions are confined to a particular network
//       connection, and the client must ensure that different sessions confined
//       to the same network connection use different session identifiers.
//
//   head  =  'bind'  <session ident>  <client file ident>  <server version>
//            <client version>  <path size>
//   body  =  <path>
//
//       Where <client file ident> is a server assigned identifier that uniquely
//       identifies a client file among all client files associated with a
//       particular file on the server. A client requests a client file
//       identifier by sending an 'ident' message to the server. The server will
//       then respond with an 'ident' message specifying the assigned client
//       file identifier. A client file identifier is a non-zero positive
//       integer stricly less than 2**64.
//
//       And <server version> is the version number of a server version that was
//       recently integrated by the client, or of a server version recently
//       produced by integration of a client version on the server, and reported
//       to the client through an 'accept' message, or zero if neither of the
//       former alternatives apply (e.g., at the beginning of the first
//       synchronization session).
//
//       And <client version> is the version number of the latest client version
//       known by the client to have been integrated by the server into <server
//       version>, or if <server version> is zero, <client version> is the
//       initial client version number (i.e., the version number of the empty
//       database).
//
//   head  =  'unbind'  <session ident>
//   body  =  none
//
//   head  =  'changeset'  <session ident>  <client version>  <server version>
//            <timestamp>  <changeset size>
//   body  =  <changeset>
//
//       Where <client version> is the version number of the client version
//       produced by the transmitted changeset.
//
//       And <server version> is the version number of the latest server version
//       integrated by the client at the time when the client produced the
//       transmitted changeset, or zero if no server version has yet been
//       integrated by the client.
//
//
// Server --> client
// -----------------
//
//   head  =  'ident'  <session ident>  <client file ident>
//   body  =  none
//
//       Where <client file ident> is a server assigned client file
//       identifier. The server never generates an identifier with the value
//       zero, and it guarantees that all identifiers generated on behalf of a
//       particular server file are unique with respect to each other. The
//       server is free to generate identical identifiers for two client files
//       that are associated with different server files.
//
//   head  =  'changeset'  <session ident>  <server version>  <client version>
//            <origin timestamp>  <origin client file ident>  <changeset size>
//   body  =  <changeset>
//
//       Where <server version> is the version number of the server version
//       produced by the transmitted changeset.
//
//       And <client version> is the version number of the latest client version
//       integrated by the server into <server version>, that is, by the server
//       at the time when the server produced the transmitted changeset,
//       presumably as the result of integrating a changeset from some other
//       client.
//
//       And <origin timestamp> is the time at which the original
//       (untransformed) changeset was produced. (FIXME: This needs to be made
//       more precise, especially with respect to the *temporal consistency
//       fix*)
//
//       And <origin client file ident> is the client file identifier of the
//       client file in the context of which the original (untransformed)
//       changeset was produced.
//
//   head  =  'accept'  <session ident>  <server version>  <client version>
//   body  =  none
//
//       Where <server version> is the version number of the server version that
//       the accepted changeset produced.
//
//       And <client version> is the version number of the client version that
//       was accepted and integrated.


using namespace std;
using namespace tightdb;


namespace {

typedef uint_fast16_t session_ident_type;
typedef uint_fast64_t file_ident_type;
typedef uint_fast64_t version_type;
typedef uint_fast64_t timestamp_type;

class connection;
class session;


class history_entry {
public:
    BinaryData changeset; // Referenced memory is not owned by this class
    version_type client_version;
    timestamp_type timestamp;
    file_ident_type client_file_ident;

    history_entry():
        client_version(0),
        timestamp(0),
        client_file_ident(0)
    {
    }

    history_entry(BinaryData c, version_type cv, timestamp_type t, file_ident_type cfi):
        changeset(c),
        client_version(cv),
        timestamp(t),
        client_file_ident(cfi)
    {
    }
};


class server_file {
public:
    const string path;

    server_file(const string& p):
        path(p),
        m_prev_client_file_ident(0)
    {
        m_first_version = 1;
    }

    ~server_file() TIGHTDB_NOEXCEPT
    {
        TIGHTDB_ASSERT(m_sessions.empty());

        typedef history::const_iterator iter;
        const iter end = m_history.end();
        for (iter i = m_history.begin(); i != end; ++i)
            delete[] i->changeset.data();
    }

    file_ident_type get_new_client_file_ident()
    {
        return ++m_prev_client_file_ident;
    }

    bool add(session*);
    void remove(session*) TIGHTDB_NOEXCEPT;

    bool is_valid_version(version_type version) TIGHTDB_NOEXCEPT
    {
        return version >= 1 && version <= get_last_version();
    }

    version_type get_first_version() TIGHTDB_NOEXCEPT
    {
        return m_first_version;
    }

    version_type get_last_version() TIGHTDB_NOEXCEPT
    {
        return m_first_version + m_history.size();
    }

    /// If the specified version is not the latest version of the file, this
    /// function fetches the history entry containing the first changeset
    /// produced after the specified version, and returns the version number of
    /// the version that the changeset produces. If the specified version is the
    /// latest version of the file, this function returns the null-version
    /// number (zero), and does not modify the referenced history entry.
    version_type get_history_entry_after(version_type version, history_entry& entry)
    {
        if (version == get_last_version())
            return 0;
        entry = m_history.at(version - m_first_version);
        return version + 1;
    }

    /// Get the history entry with the changeset that produces the specified
    /// version, and return the version number of the preceeding version. The
    /// effect of passing the null-version number (zero) is unspecified.
    version_type get_history_entry_before(version_type version, history_entry& entry)
    {
        entry = m_history.at(version - m_first_version - 1);
        return version - 1;
    }

    // Returns new server version. Ownership of changeset buffer is passed from
    // caller to callee.
    version_type add_history_entry(history_entry);

private:
    typedef vector<history_entry> history;
    history m_history;
    version_type m_first_version;

    typedef map<file_ident_type, session*> sessions;
    sessions m_sessions;

    file_ident_type m_prev_client_file_ident;
};


class server: private util::Logger {
public:
    server(util::Logger* root_logger, bool log_everything);
    ~server();

    void start(string listen_address, string listen_port, bool reuse_address = false);

    util::network::endpoint listen_endpoint() const
    {
        return m_acceptor.local_endpoint();
    }

    void run()
    {
        m_service.run();
    }

    void remove_connection(connection*);

    server_file* get_file(const string& path) TIGHTDB_NOEXCEPT
    {
        typedef files::const_iterator iter;
        iter i = m_files.find(path);
        return i == m_files.end() ? 0 : i->second;
    }

    server_file& get_or_create_file(const string& path)
    {
        typedef files::iterator iter;
        iter i = m_files.insert(pair<string, server_file*>(path, 0)).first; // Throws
        if (!i->second)
            i->second = new server_file(path); // Throws
        return *i->second;
    }

private:
    util::Logger* const m_root_logger;
    const bool m_log_everything;

    const string m_listen_address;
    const string m_listen_port;
    util::network::io_service m_service;
    util::network::acceptor m_acceptor;
//    unsigned short m_assigned_listen_port;
    int_fast64_t m_next_conn_id;
    util::UniquePtr<connection> m_next_conn;
    util::network::endpoint m_next_conn_endpoint;
    typedef set<connection*> connections;
    connections m_connections;
    typedef map<string, server_file*> files;
    files m_files;

    void initiate_accept();
    void handle_accept(util::error_code);

    void do_log(const std::string& msg) TIGHTDB_OVERRIDE
    {
        if (m_root_logger)
            Logger::do_log(m_root_logger, msg);
    }

    friend class connection;
    friend class session;
};


class connection: private util::Logger {
public:
    connection(server& serv, int_fast64_t id, util::network::io_service& service):
        m_server(serv),
        m_id(id),
        m_socket(service),
        m_input_stream(m_socket)
    {
        ostringstream out;
        out << "Connection["<<id<<"]: ";
        m_log_prefix = out.str();
    }

    ~connection() TIGHTDB_NOEXCEPT;

    void start(const util::network::endpoint& ep)
    {
        log("Connection from %2:%3", m_id, ep.address(), ep.port());
        initiate_read_head();
    }

    void enqueue_output_message(const string& head, BinaryData body, session* sess)
    {
        bool resume = m_output_messages.empty();
        m_output_messages.push(output_message(head, body, sess)); // Throws
        if (resume)
            resume_output();
    }

private:
    server& m_server;
    const int_fast64_t m_id;
    util::network::socket m_socket;
    util::network::buffered_input_stream m_input_stream;
    static const size_t s_max_head_size = 192;
    char m_input_head_buffer[s_max_head_size];
    util::UniquePtr<char[]> m_input_body_buffer;
    string m_log_prefix;

    typedef map<session_ident_type, session*> sessions;
    sessions m_sessions;

    class output_message {
    public:
        string head;
        BinaryData body; // Referenced memory is owned by this class
        session* sess;
        output_message(const string& h, BinaryData b, session* s):
            head(h),
            body(b),
            sess(s)
        {
        }
    };

    queue<output_message> m_output_messages;

    void initiate_read_head()
    {
        m_input_stream.async_read_until(m_input_head_buffer, s_max_head_size, '\n',
                                        bind(&connection::handle_read_head, this));
    }

    void handle_read_head(util::error_code, size_t n);

    void handle_read_changeset(session_ident_type, version_type client_version,
                               version_type server_version, timestamp_type,
                               util::error_code, size_t n);

    void handle_read_bind_path(session_ident_type, file_ident_type client_file_ident,
                               version_type server_version, version_type client_version,
                               util::error_code, size_t n);

    void handle_read_ident_path(session_ident_type, util::error_code, size_t n);

    void resume_output()
    {
        const output_message& message = m_output_messages.front();
        async_write(m_socket, message.head.data(), message.head.size(), bind(&connection::handle_write_head, this));
    }

    void handle_write_head(util::error_code, size_t n);

    void handle_write_body(util::error_code, size_t n);

    void read_error(util::error_code ec)
    {
        log("ERROR: Reading failed: %1", ec.message());
        close();
    }

    void write_error(util::error_code ec)
    {
        log("ERROR: Writing failed: %1", ec.message());
        close();
    }

    void close();

    void do_log(const std::string& msg) TIGHTDB_OVERRIDE
    {
        if (m_server.m_root_logger)
            Logger::do_log(m_server.m_root_logger, m_log_prefix + msg);
    }

    friend class server;
    friend class session;
};


class session {
public:
    session(connection& conn, server_file& file, session_ident_type session_ident,
            file_ident_type client_file_ident, version_type server_version,
            version_type client_version):
        m_connection(conn),
        m_server_file(file),
        m_session_ident(session_ident),
        m_client_file_ident(client_file_ident),
        m_server_version(server_version),
        m_client_version(client_version),
        m_client_version_threshold(client_version),
        m_transmission_in_progress(false)
    {
        // Check whether we already integrated a later client version during
        // an earlier session
        version_type version = file.get_last_version();
        while (version != server_version) {
            history_entry entry;
            version_type prev_version = file.get_history_entry_before(version, entry);
            if (entry.client_file_ident == client_file_ident) {
                m_client_version_threshold = entry.client_version;
                break;
            }
            version = prev_version;
        }
    }

    ~session() TIGHTDB_NOEXCEPT
    {
        m_server_file.remove(this);
    }

    server_file& get_server_file() TIGHTDB_NOEXCEPT
    {
        return m_server_file;
    }

    file_ident_type get_client_file_ident() const TIGHTDB_NOEXCEPT
    {
        return m_client_file_ident;
    }

    version_type get_client_version_threshold() const TIGHTDB_NOEXCEPT
    {
        return m_client_version_threshold;
    }

    void resume_transmission()
    {
        if (!m_transmission_in_progress)
            continue_transmission();
    }

    void on_message_transmitted()
    {
        TIGHTDB_ASSERT(m_transmission_in_progress);
        m_transmission_in_progress = false;
        continue_transmission();
    }

private:
    connection& m_connection;

    server_file& m_server_file;

    const session_ident_type m_session_ident;

    const file_ident_type m_client_file_ident;

    // The server version number of the last server version reported to the
    // client either via a 'changeset' message or an 'accept' message.
    version_type m_server_version;

    // The client version number of the last client version integrated into
    // `server_version`.
    version_type m_client_version;

    // The last client version integrated by the server at the time the
    // synchronization session was initiated (a constant). Used to detect when a
    // received changeset was already integrated during an earlier
    // synchronization sessions.
    version_type m_client_version_threshold;

    bool m_transmission_in_progress;

    void continue_transmission()
    {
        history_entry entry;
        version_type next_version =
            m_server_file.get_history_entry_after(m_server_version, entry);
        if (!next_version)
            return; // Nothing more to do right now

        if (entry.client_file_ident == m_client_file_ident) {
            version_type client_version = entry.client_version;
            version_type server_version = next_version;
            if (m_connection.m_server.m_log_everything) {
                m_connection.log("Session[%1]: Sending: Accept changeset %2 -> %3 "
                                 "(producing server version %4)", m_session_ident,
                                 client_version-1, client_version, server_version);
            }
            ostringstream out;
            out << "accept "<<m_session_ident<<" "<<server_version<<" "<<client_version<<"\n";
            string head = out.str();
            BinaryData body; // No body
            m_connection.enqueue_output_message(head, body, this); // Throws
            m_server_version = server_version;
            m_client_version = client_version;
        }
        else {
            version_type server_version = next_version;
            version_type client_version = m_client_version;
            if (m_connection.m_server.m_log_everything) {
                m_connection.log("Session[%1]: Sending: Changeset %2 -> %3 of size %4 "
                                 "with origin timestamp %5 and origin client file identifier %6 "
                                 "(last integrated client version is %7)", m_session_ident,
                                 m_server_version, server_version, entry.changeset.size(),
                                 entry.timestamp, entry.client_file_ident, client_version);
            }
            ostringstream out;
            out << "changeset "<<m_session_ident<<" "<<server_version<<" "
                ""<<client_version<<" "<<entry.timestamp<<" "<<entry.client_file_ident<<" "
                ""<<entry.changeset.size()<<"\n";
            string head = out.str();
            BinaryData body = entry.changeset;
            m_connection.enqueue_output_message(head, body, this); // Throws
            m_server_version = server_version;
        }

        m_transmission_in_progress = true;
    }
};




bool server_file::add(session* sess)
{
    typedef sessions::iterator iter;
    pair<iter, bool> p =
        m_sessions.insert(make_pair(sess->get_client_file_ident(), sess)); // Throws
    bool was_inserted = p.second;
    return was_inserted;
}


void server_file::remove(session* sess) TIGHTDB_NOEXCEPT
{
    file_ident_type client_file_ident = sess->get_client_file_ident();
    TIGHTDB_ASSERT(m_sessions.find(client_file_ident) != m_sessions.end());
    m_sessions.erase(client_file_ident);
}


version_type server_file::add_history_entry(history_entry entry)
{
    m_history.push_back(entry); // Throws

    typedef sessions::const_iterator iter;
    iter end = m_sessions.end();
    for (iter i = m_sessions.begin(); i != end; ++i) {
        session* sess = i->second;
        sess->resume_transmission();
    }

    return get_last_version();
}



server::server(util::Logger* root_logger, bool log_everything):
    m_root_logger(root_logger),
    m_log_everything(log_everything),
    m_acceptor(m_service),
    m_next_conn_id(0)
{
}


server::~server()
{
    {
        typedef connections::const_iterator iter;
        iter end = m_connections.end();
        for (iter i = m_connections.begin(); i != end; ++i) {
            connection* conn = *i;
            delete conn;
        }
    }
    {
        typedef files::const_iterator iter;
        iter end = m_files.end();
        for (iter i = m_files.begin(); i != end; ++i) {
            server_file* file = i->second;
            delete file;
        }
    }
}


void server::start(string listen_address, string listen_port, bool reuse_address)
{
    util::network::resolver resolver(m_service);
    util::network::resolver::query query(listen_address, listen_port,
                                         util::network::resolver::query::passive |
                                         util::network::resolver::query::address_configured);
    util::network::endpoint::list endpoints;
    resolver.resolve(query, endpoints);

    typedef util::network::endpoint::list::iterator iter;
    iter i = endpoints.begin();
    iter end = endpoints.end();
    for (;;) {
        util::error_code ec;
        m_acceptor.open(i->protocol(), ec);
        if (!ec) {
            if (reuse_address)
                m_acceptor.set_option(util::network::socket_base::reuse_address(true), ec);
            if (!ec) {
                m_acceptor.bind(*i, ec);
                if (!ec)
                    break;
            }
            m_acceptor.close();
        }
        if (++i == end)
            throw runtime_error("Could not create a listening socket: All endpoints failed");
    }

    m_acceptor.listen();

    util::network::endpoint local_endpoint = m_acceptor.local_endpoint();
    log("Listening on %1:%2", local_endpoint.address(), local_endpoint.port());

    initiate_accept();
}


void server::initiate_accept()
{
    m_next_conn.reset(new connection(*this, ++m_next_conn_id, m_service));
    m_acceptor.async_accept(m_next_conn->m_socket, m_next_conn_endpoint,
                            bind(&server::handle_accept, this));
}


void server::handle_accept(util::error_code ec)
{
    if (ec)
        throw util::system_error(ec);
    connection* conn = m_next_conn.get();
    m_connections.insert(conn); // Throws
    m_next_conn.release();
    conn->start(m_next_conn_endpoint);
    initiate_accept();
}


void server::remove_connection(connection* conn)
{
    m_connections.erase(conn);
}



connection::~connection() TIGHTDB_NOEXCEPT
{
    typedef sessions::const_iterator iter;
    iter end = m_sessions.end();
    for (iter i = m_sessions.begin(); i != end ; ++i) {
        session* sess = i->second;
        delete sess;
    }
}


void connection::handle_read_head(util::error_code ec, size_t n)
{
    if (ec) {
        if (ec != util::error::operation_aborted)
            read_error(ec);
        return;
    }

    util::MemoryInputStream in;
    TIGHTDB_ASSERT(n >= 1);
    in.set_buffer(m_input_head_buffer, m_input_head_buffer+(n-1));
    in.unsetf(std::ios_base::skipws);
    string message_type;
    in >> message_type;
    if (message_type == "changeset") {
        session_ident_type session_ident;
        version_type client_version, server_version;
        timestamp_type timestamp;
        size_t log_size;
        char sp_1, sp_2, sp_3, sp_4, sp_5;
        in >> sp_1 >> session_ident >> sp_2 >> client_version >> sp_3 >>
            server_version >> sp_4 >> timestamp >> sp_5 >> log_size;
        bool good = in && in.eof() && sp_1 == ' ' && sp_2 == ' ' && sp_3 == ' ' && sp_4 == ' ' &&
            sp_5 == ' ';
        if (good) {
            m_input_body_buffer.reset(new char[log_size]); // Throws
            m_input_stream.async_read(m_input_body_buffer.get(), log_size,
                                      bind(&connection::handle_read_changeset, this,
                                           session_ident, client_version, server_version,
                                           timestamp));
            return;
        }
    }
    else if (message_type == "bind") {
        session_ident_type session_ident;
        file_ident_type client_file_ident;
        version_type server_version, client_version;
        size_t path_size;
        char sp_1, sp_2, sp_3, sp_4, sp_5;
        in >> sp_1 >> session_ident >> sp_2 >> client_file_ident >> sp_3 >>
            server_version >> sp_4 >> client_version >> sp_5 >> path_size;
        bool good = in && in.eof() && sp_1 == ' ' && sp_2 == ' ' && sp_3 == ' ' && sp_4 == ' ' &&
            sp_5 == ' ';
        if (good) {
            m_input_body_buffer.reset(new char[path_size]); // Throws
            m_input_stream.async_read(m_input_body_buffer.get(), path_size,
                                      bind(&connection::handle_read_bind_path,
                                           this, session_ident, client_file_ident,
                                           server_version, client_version));
            return;
        }
    }
    else if (message_type == "unbind") {
        session_ident_type session_ident;
        char sp;
        in >> sp >> session_ident;
        bool good = in && in.eof() && sp == ' ';
        if (good) {
            typedef sessions::iterator iter;
            iter i = m_sessions.find(session_ident);
            if (i == m_sessions.end()) {
                log("ERROR: Bad session identifier %1 in 'unbind' message", session_ident);
                close();
                return;
            }
            session* sess = i->second;
            log("Session[%1]: Received: Unbind", session_ident);
            m_sessions.erase(session_ident);
            delete sess;
            initiate_read_head();
            return;
        }
    }
    else if (message_type == "ident") {
        session_ident_type session_ident;
        size_t path_size;
        char sp_1, sp_2;
        in >> sp_1 >> session_ident >> sp_2 >> path_size;
        bool good = in && in.eof() && sp_1 == ' ' && sp_2 == ' ';
        if (good) {
            m_input_body_buffer.reset(new char[path_size]); // Throws
            m_input_stream.async_read(m_input_body_buffer.get(), path_size,
                                      bind(&connection::handle_read_ident_path,
                                           this, session_ident));
            return;
        }
    }
    log("ERROR: Bad message header '%1'", StringData(m_input_head_buffer, n-1));
    close();
}


void connection::handle_read_changeset(session_ident_type session_ident,
                                       version_type client_version, version_type server_version,
                                       timestamp_type timestamp, util::error_code ec, size_t n)
{
    if (ec) {
        if (ec != util::error::operation_aborted)
            read_error(ec);
        return;
    }

    util::UniquePtr<char[]> changeset_owner(m_input_body_buffer.release());
    BinaryData changeset(changeset_owner.get(), n);

    typedef sessions::iterator iter;
    iter i = m_sessions.find(session_ident);
    if (i == m_sessions.end()) {
        log("ERROR: Bad session identifier %1 in 'changeset' message", session_ident);
        close();
        return;
    }

    if (m_server.m_log_everything) {
        log("Session[%1]: Received: Changeset %2 -> %3 of size %4 with timestamp %5 "
            "(last integrated server version is %6)", session_ident, client_version-1,
            client_version, n, timestamp, server_version);
    }

    session& sess = *i->second;

    if (client_version <= sess.get_client_version_threshold()) {
        if (m_server.m_log_everything)
            log("Session[%1]: Ignoring previously integrated changeset", session_ident);
    }
    else {
        server_file& file = sess.get_server_file();
        version_type first_server_version = file.get_first_version();
        version_type corrected_server_version = server_version > 0 ? server_version :
            first_server_version;
        version_type current_server_version = file.get_last_version();
        if (corrected_server_version > current_server_version) {
            log("Session[%1]: ERROR: Bad server version %2", session_ident, server_version);
            close();
            return;
        }

        // If the last changeset is from a different client file, or if the
        // history is empty, require that the last integragted server version of
        // the incoming changeset is the current server version, i.e., the one
        // produced by the last changeset in the local history.
        bool from_same_client_file = false;
        if (current_server_version > first_server_version) {
            history_entry last_entry;
            file.get_history_entry_before(current_server_version, last_entry);
            from_same_client_file = (last_entry.client_file_ident == sess.get_client_file_ident());
        }
        if (from_same_client_file || corrected_server_version == current_server_version) {
            history_entry entry(changeset, client_version, timestamp,
                                sess.get_client_file_ident());
            file.add_history_entry(entry); // Throws
            changeset_owner.release();
        }
        else {
            // Merge conflicting changes

            // WARNING: Strictly speaking, the following is not the correct
            // resolution of the conflict between two identical initial
            // changesets, but it is done as a temporary work-around to allow
            // the current version of the Cocoa binding to carry out an initial
            // schema creating transaction without getting into an immediate
            // unrecoverable conflict. It does not work in general as even the
            // initial changeset is allowed to contain elements that are
            // additive rather than idempotent.
            TIGHTDB_ASSERT(current_server_version > 1);
            history_entry first_entry;
            file.get_history_entry_after(1, first_entry);
            bool identical_first_schema_creating_transactions =
                client_version == 2 && corrected_server_version == first_server_version &&
                changeset == first_entry.changeset;
            if (!identical_first_schema_creating_transactions) {
                log("Session[%1]: ERROR: Conflict (%2 vs %3)", session_ident, changeset.size(),
                    first_entry.changeset.size());
/*
                ofstream out_1("/tmp/conflict.server");
                out_1.write(first_entry.changeset.data(), first_entry.changeset.size());
                ofstream out_2("/tmp/conflict.client");
                out_2.write(changeset.data(), changeset.size());
*/
                close();
                return;
            }

            log("Session[%1]: Conflict on identical initial schema-creating transactions resolved "
                "(impropperly)", session_ident);
            BinaryData empty_changeset;
            history_entry entry(empty_changeset, client_version, timestamp,
                                sess.get_client_file_ident());
            file.add_history_entry(entry); // Throws
        }

        sess.resume_transmission(); // Throws
    }

    // Read next message from client
    initiate_read_head();
}


void connection::handle_read_bind_path(session_ident_type session_ident,
                                       file_ident_type client_file_ident,
                                       version_type server_version, version_type client_version,
                                       util::error_code ec, size_t n)
{
    if (ec) {
        if (ec != util::error::operation_aborted)
            read_error(ec);
        return;
    }

    string path(m_input_body_buffer.get(), m_input_body_buffer.get()+n); // Throws
    m_input_body_buffer.reset();

    log("Session[%1]: Received: Bind client file %2 to server file '%3' continuing "
        "synchronization from server version %4, whose last integrated client version is %5",
        session_ident, client_file_ident, path, server_version, client_version);

    server_file* file = m_server.get_file(path);
    if (!file) {
        log("Session[%1]: ERROR: Unknown server file", session_ident);
        close();
    }
    version_type corrected_server_version = server_version > 0 ? server_version :
        file->get_first_version();
    if (!file->is_valid_version(corrected_server_version)) {
        log("Session[%1]: ERROR: Bad server version", session_ident);
        close();
    }
    typedef sessions::iterator iter;
    pair<iter, bool> p = m_sessions.insert(make_pair(session_ident, static_cast<session*>(0)));
    bool was_inserted = p.second;
    if (!was_inserted) {
        log("Session[%1]: ERROR: Client file already bound in this session", session_ident);
        close();
        return;
    }

    session* sess = 0;
    try {
        sess = new session(*this, *file, session_ident, client_file_ident,
                           corrected_server_version, client_version); // Throws
        p.first->second = sess;
        if (!file->add(sess)) { // Throws
            log("Session[%1]: ERROR: Client file already bound in another session", session_ident);
            delete sess;
            m_sessions.erase(p.first);
            close();
            return;
        }
    }
    catch (...) {
        if (sess)
            delete sess;
        m_sessions.erase(p.first);
        throw;
    }

    sess->resume_transmission(); // Throws

    initiate_read_head(); // Throws
}


void connection::handle_read_ident_path(session_ident_type session_ident,
                                        util::error_code ec, size_t n)
{
    if (ec) {
        if (ec != util::error::operation_aborted)
            read_error(ec);
        return;
    }

    string path(m_input_body_buffer.get(), m_input_body_buffer.get()+n); // Throws
    m_input_body_buffer.reset();

    log("Session[%1]: Received: Get unique client file identifier for server file '%2'",
        session_ident, path);

    server_file& file = m_server.get_or_create_file(path); // Throws
    file_ident_type client_file_ident = file.get_new_client_file_ident();

    log("Session[%1]: Sending: New unqiue client file identifier is %2",
        session_ident, client_file_ident);
    ostringstream out;
    out << "ident "<<session_ident<<" "<<client_file_ident<<"\n";
    string head = out.str();
    BinaryData body; // No body
    session* sess = 0; // No real session yet
    enqueue_output_message(head, body, sess);
    initiate_read_head();
}


void connection::handle_write_head(util::error_code ec, size_t n)
{
    if (ec) {
        if (ec != util::error::operation_aborted)
            write_error(ec);
        return;
    }

    TIGHTDB_ASSERT(!m_output_messages.empty());
    const output_message& message = m_output_messages.front();
    TIGHTDB_ASSERT(n == message.head.size());
    if (message.body) {
        async_write(m_socket, message.body.data(), message.body.size(), bind(&connection::handle_write_body, this));
    }
    else {
        util::error_code ec; // ok
        size_t n = 0;
        handle_write_body(ec, n);
    }
}


void connection::handle_write_body(util::error_code ec, size_t n)
{
    if (ec) {
        if (ec != util::error::operation_aborted)
            write_error(ec);
        return;
    }

    TIGHTDB_ASSERT(!m_output_messages.empty());
    const output_message& message = m_output_messages.front();
    TIGHTDB_ASSERT(n == message.body.size());
    session* sess = message.sess;
    m_output_messages.pop();

    bool resume = !m_output_messages.empty();

    if (sess)
        sess->on_message_transmitted(); // Throws

    if (resume)
        resume_output();
}


void connection::close()
{
    m_socket.close();
    m_server.remove_connection(this);

    log("Connection closed due to error");
    delete this;
}


} // anonymous namespace





int main(int argc, char* argv[])
{
    string listen_address = util::network::host_name();
    string listen_port = "7800";
    bool reuse_address = false;
    int log_level = 1;

    // Process command line
    {
        const char* prog = argv[0];
        --argc;
        ++argv;
        bool error = false;
        bool help  = false;
        int argc2 = 0;
        for (int i=0; i<argc; ++i) {
            char* arg = argv[i];
            if (arg[0] != '-') {
                argv[argc2++] = arg;
                continue;
            }
            if (strcmp(arg, "-h") == 0 || strcmp(arg, "--help") == 0) {
                help = true;
                continue;
            }
            else if (strcmp(arg, "-p") == 0 || strcmp(arg, "--listen-port") == 0) {
                if (i+1 < argc) {
                    listen_port = argv[++i];
                    continue;
                }
            }
            else if (strcmp(arg, "-r") == 0 || strcmp(arg, "--reuse-address") == 0) {
                reuse_address = true;
                continue;
            }
            else if (strcmp(arg, "-l") == 0 || strcmp(arg, "--log-level") == 0) {
                if (i+1 < argc) {
                    istringstream in(argv[++i]);
                    in.unsetf(std::ios_base::skipws);
                    int v = 0;
                    in >> v;
                    if (in && in.eof() && v >= 0 && v <= 2) {
                        log_level = v;
                        continue;
                    }
                }
            }
            error = true;
            break;
        }
        argc = argc2;

        if (argc > 0)
            listen_address = argv[0];
        if (argc > 1)
            error = true;

        if (help) {
            cerr <<
                "Synopsis: "<<prog<<"  [ADDRESS]\n"
                "\n"
                "Options:\n"
                "  -h, --help           Display command-line synopsis followed by the list of\n"
                "                       available options.\n"
                "  -p, --listen-port    The listening port. (default '"<<listen_port<<"')\n"
                "  -r, --reuse-address  Allow immediate reuse of listening port (unsafe).\n"
                "  -l, --log-level      Set log level (0 for nothing, 1 for normal, 2 for\n"
                "                       everything).\n";
            return 0;
        }

        if (error) {
            cerr <<
                "ERROR: Bad command line.\n"
                "Try `"<<prog<<" --help`\n";
            return 1;
        }
    }

    util::UniquePtr<util::Logger> logger;
    bool enable_logging = (log_level > 0);
    if (enable_logging)
        logger.reset(new util::Logger);

    bool log_everything = (log_level > 1);
    server serv(logger.get(), log_everything);
    serv.start(listen_address, listen_port, reuse_address);
    serv.run();
}
