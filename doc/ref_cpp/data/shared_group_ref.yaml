#
# C++ reference documentation for the SharedGroup class.
#

ID         : class_shared_group
TITLE      : SharedGroup
SUMMARY    : &g_shared_group_summary
             Sharing groups
DESCR      : &g_shared_group_descr
             >
             Database files can be shared between running applications.

             When two threads or processes want to access the same
             database file, they must each create their own
             instance of SharedGroup.

             If the database file does not already exist, it will
             be created. When multiple threads are involved, it is
             safe to let the first thread, that gets to it, create
             the file.

             While at least one instance of SharedGroup exists for
             a specific database file, a lock file will exist
             too. The lock file will be placed in the same
             directory as the database file, and its name is
             derived by adding the suffix '.lock' to the name of
             the database file.

             Processes that share a database file must reside on
             the same host.

             Moreover, the class also provides a transactional
             interface to TightDB. Transactions are divided into
             read and write transactions. While read transactions
             do not modify the table and thereby the group, write
             transactions do. This division is important to remember
             as derived objects (tables, views, etc.) are either
             writable or not.
SEE        :
EXAMPLES:
- DESCR    :
  CODE     : ex_sharedgroup_intro
IGNORE     : []
CATEGORIES:
- Constructor:
  METHODS:
  - g_shared_group_constructor:
      NAMES    : SharedGroup
      SUMMARY  : &g_shared_group_constructor_summary
                 Create a shared group.
      DESCR    :
      - TEXT   : &g_shared_group_constructor_descr
                 >
                 Open a shared group (will be created if it does not already exist).

                 By default the shared group will be fully durable, so that each commit writes its changes
                 to disk in an atomic manner that guarantees that the file is always consistent.

                 If your data is transient, and does not need to persist to disk (like for caching or
                 shared state between processes). You can open the shared group in mem-only mode. Then the
                 file will just be used for identification and backing; it will be removed when there
                 are no more processes using it.

                 Note that a shared group can only be opened in the mode it was created in.

      - TEXT   : &g_shared_group_constructor_descr_unattached
                 >
                 A SharedGroup may also be constructed in an unattached
                 state (2). See {@link g_shared_group_open} and
                 {@link g_shared_group_is_attached} for more on this.
      ENUM_SIG :
      - SIG    : >
                 SharedGroup(const std::string& path, bool no_create = false,
                             DurabilityLevel dlevel = durability_Full);
      - SIG    : SharedGroup(unattached_tag);
      PARAMS:
      - NAME   : path
        TYPES  : const std::string&
        DESCR  : *g_open_filesystem_path_descr
      - NAME   : no_create
        TYPES  : bool
        DESCR  : &g_shared_group_constructor_parm2_descr
                 If set to <tt>true</tt>, File::NotFound will be thrown
                 if the file does not already exist.
      - NAME   : dlevel
        TYPES  : DurabilityLevel
        DESCR  : &g_shared_group_constructor_parm3_descr
                 Durability Level (durability_Full or durability_MemOnly)
      RETURN:
        TYPES  : SharedGroup
        DESCR  : &g_shared_group_constructor_return1_descr
                 A shared group.
      THROWS:
      - EXCEPT : &cpp_permission_denied_except
                 File::PermissionDenied
        DESCR  : &g_permission_denied_descr
                 >
                 The user has insufficient permissions to perform the IO
                 operation.
      - EXCEPT : &cpp_not_found_except
                 File::NotFound
        DESCR  : &g_not_found_descr
                 A part of the path was not found.
      - EXCEPT : &cpp_invalid_database_except
                 InvalidDatabase
        DESCR  : &g_shared_group_invalid_database_descr
                 The file does not appear to contain a valid TightDB database.
      - EXCEPT : &cpp_access_error_except
                 File::AccessError
        DESCR  : &g_access_error_descr
                 For some reason, we can't access the database.
      - EXCEPT : &cpp_runtime_error_except
                 std::runtime_error
        DESCR  : &g_runtime_error_descr
                 A serious error occurred.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_constructor
        DESCR  :
- Utilities:
  METHODS:
  - g_shared_group_open:
      NAMES    : open
      SUMMARY  : &g_shared_group_open_summary
                 Is this SharedGroup instance in its attached state?
      SIGNATURE: >
                 open(const std::string& file, bool no_create = false, DurabilityLevel dlevel = durability_Full);
      DESCR    : &g_shared_group_open_descr
                 Attach this SharedGroup instance to the specified
                 database file.

                 If the database file does not already exist, it will
                 be created (unless <tt>no_create</tt> is set to
                 true.) When multiple threads are involved, it is safe
                 to let the first thread, that gets to it, create the
                 file.

                 While at least one instance of SharedGroup exists for
                 a specific database file, a "lock" file will be
                 present too. The lock file will be placed in the same
                 directory as the database file, and its name will be
                 derived by appending ".lock" to the name of the
                 database file.

                 When multiple SharedGroup instances refer to the same
                 file, they must specify the same durability level,
                 otherwise an exception will be thrown.

                 Calling open() on a SharedGroup instance that is
                 already in the attached state has undefined behavior.
      PARAMS:
      - NAME   : path
        TYPES  : const std::string&
        DESCR  : *g_open_filesystem_path_descr
      - NAME   : no_create
        TYPES  : bool
        DESCR  : &g_shared_group_open_parm2_descr
                 If set to <tt>true</tt>, File::NotFound will be thrown
                 if the file does not already exist.
      - NAME   : dlevel
        TYPES  : DurabilityLevel
        DESCR  : &g_shared_group_open_parm3_descr
                 Durability Level (durability_Full or durability_MemOnly)
      THROWS:
      - EXCEPT : File::AccessError
        DESCR  : &g_shared_group_open_throws_descr
                 If the file could not be opened. If the reason
                 corresponds to one of the exception types that are
                 derived from File::AccessError, the derived exception
                 type is thrown. Note that InvalidDatabase is among
                 these derived exception types.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_shared_group_open
  - g_shared_group_is_attached:
      NAMES    : is_attached
      SUMMARY  : &g_shared_group_is_attached_summary
                 Is this SharedGroup instance in its attached state?
      DESCR    : &g_shared_group_is_attached_descr
                 A shared group may be created in the unattached
                 state, and then later attached to a file with a call
                 to one of the open() methods. Calling any method
                 other than open(), is_attached(), and ~SharedGroup()
                 on an unattached instance results in undefined
                 behavior.
      CONST    : true
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if attached, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_shared_group_is_attached
  - g_shared_group_reserve:
      NAMES    : reserve
      SUMMARY  : &g_shared_group_reserve_summary
                 Reserve disk space now.
      DESCR    : &g_shared_group_reserve_descr
                 Reserve disk space now to avoid allocation errors at
                 a later point in time, and to minimize on-disk
                 fragmentation. In some cases, less fragmentation
                 translates into improved performance.

                 A call to this method will make the database file at
                 least as big as the specified size, and, if the
                 platform supports it, disk space will be allocated
                 for the entire file.

                 If the database file is already as big as the
                 specified size, or bigger, this method will not
                 affect the size of the file, but, if the platform
                 supports it, it will still cause previously
                 unallocated disk space to be allocated.
      PARAMS:
      - NAME   : size_in_bytes
        TYPES  : std::size_t
        DESCR  : The total number of bytes to reserve on disk for this database.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_shared_group_reserve
  - g_shared_group_has_changed:
      NAMES    : has_changed
      SUMMARY  : &g_shared_group_has_changed_summary
                 Has shared group been changed since last transaction?
      DESCR    : &g_shared_group_has_changed_descr
                 >
                 This method tests if the shared group has been modified (by another process),
                 since the last transaction.

                 It has very little overhead and does not affect other processes, so it is
                 ok to call it at regular intervals (like in the idle handler of an application).
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if it has changed, <code>false</code> otherwise.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_has_changed
        DESCR  :
- Write transactions:
  METHODS:
  - g_shared_group_begin_write:
      NAMES    : begin_write
      SUMMARY  : &g_shared_group_begin_write_summary
                 Initiate a transaction.
      DESCR    : &g_shared_group_begin_write_descr
                 Begin writing to a shared group.
      RETURN:
        TYPES  : Group&
        DESCR  : &g_shared_group_begin_write_return1_descr
                 A group.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_begin_write
        DESCR  :
  - g_shared_group_commit:
      NAMES    : commit
      SUMMARY  : &g_shared_group_commit_summary
                 Commit a transaction.
      DESCR    : &g_shared_group_commit_descr
                 This method closes a transaction and all changes are written to the shared group.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_commit
        DESCR  :
  - g_shared_group_rollback:
      NAMES    : rollback
      SUMMARY  : &g_shared_group_rollback_summary
                 Rollback a transaction.
      DESCR    : &g_shared_group_rollback_descr
                 This method closes a transaction and discards all changes done to the shared group,
                 unless a commit has already been done. It is ok to call rollback multiple times. 
                 Any additional calls to rollback following a commit or rollback are treated as no-ops.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_rollback
        DESCR  :
 # - g_shared_group_interrupt_transact:
 #     NAMES    : interrupt_transact
 #     SUMMARY  : &g_shared_group_interrupt_transact_summary
 #                Interrupt any blocking call.
 #     DESCR    : &g_shared_group_interrupt_transact_descr
 #                >
 #                This function may be called asynchronously to interrupt any
 #                blocking call that is part of a transaction in a replication
 #                setup. Only {@link g_shared_group_begin_write} and
 #                modifying function that are part
 #                of a write transaction can block. The transaction is
 #                interrupted only if such a call is blocked or would
 #                block. This function may be called from a different thread. It
 #                may not be called directly from a system signal handler. When
 #                a transaction is interrupted, the only valid member function
 #                to call is {@link g_shared_group_rollback}. If a client calls
 #                {@link g_shared_group_clear_interrupt_transact} after having
 #                called {@link g_shared_group_rollback}, it
 #                may then resume normal operation on this database/shared group.
 #                Currently,
 #                transaction interruption works by throwing an exception from
 #                one of the mentioned member functions that may block.
 #     EXAMPLES:
 #     - CODE   : ex_cpp_shared_group_interrupt_transact
 #       DESCR  :
 # - g_shared_group_clear_interrupt_transact:
 #     NAMES    : clear_interrupt_transact
 #     SUMMARY  : &g_shared_group_clear_interrupt_transact_summary
 #                Clean up interrupted state.
 #     DESCR    : &g_shared_group_clear_interrupt_transact_descr
 #                >
 #                This method clears the interrupted state of the shared group after rolling
 #                back a transaction. It is not an error to call this function
 #                in a situation where no interruption has occured.
 #     SEE      : g_shared_group_interrupt_transact
 #     EXAMPLES:
 #     - CODE   : ex_cpp_shared_group_clear_interrupt_transact
 #       DESCR  :
- Read transactions:
  METHODS:
  - g_shared_group_begin_read:
      NAMES    : begin_read
      SUMMARY  : &g_shared_group_begin_read_summary
                 Initiate reading from a shared group.
      DESCR    : &g_shared_group_begin_read_descr
                 >
                 Begin reading from a shared group. During the read transaction,
                 you have a fully consistent immutable view of the group.
      CONST    : True
      RETURN:
        TYPES  : Group&
        DESCR  : A group.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_begin_read
        DESCR  :
  - g_shared_group_end_read:
      NAMES    : end_read
      SUMMARY  : &g_shared_group_end_read_summary
                 Terminate read transaction. It is ok to call end_read multiple times, the
                 first call will terminate the transaction. Any additional calls are treated
                 as no-ops
      DESCR    : &g_shared_group_end_read_descr
                 This method terminates the read transaction.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_end_read
        DESCR  :
