#
# C++ reference documentation for the SharedGroup class.
#

ID         : class_shared_group
TITLE      : SharedGroup
SUMMARY    : &g_shared_group_summary
             Sharing groups between processes.
DESCR      :
- TEXT     : &g_shared_group_descr
             >
             Database files can be shared between running applications.

             When multiple threads or processes want to access the same
             database file, they must each do so through their own
             instance of SharedGroup.

             If the database file does not already exist, it will
             be created.

             While at least one instance of SharedGroup exists for
             a specific database file, a lock file will exist
             too. The lock file will be placed in the same
             directory as the database file, and its name is
             derived by adding the suffix '.lock' to the name of
             the database file.

             Processes that share a database file must reside on
             the same host. Sharing also has a storage overhead, so
             database files created through SharedGroup are often
             a bit larger than database files created through Group.
             The minimal size of a database file created through
             SharedGroup is 4Kb.

             Moreover, the class also provides a transactional
             interface to Realm. Transactions are divided into
             read and write transactions. While read transactions
             do not modify the table and thereby the group, write
             transactions do. This division is important to remember
             as derived objects (tables, views, etc.) are either
             writable or not.

             Nested transactions are not supported.

             Read transactions are significantly faster than write
             transactions. Multiple read transactions may occur concurrently
             with each other or with write transactions, while write transactions
             are serialized with respect to each other.
             Transactions are fully isolated: throughout a read transaction it will see
             the state of the data as it was when the read transactions started,
             regardless of any concurrent commits from write transactions.

- TEXT     : The scoped transaction objects {@link g_write_trans_begin_write}
             and {@link g_read_trans_begin_read}
             are provided to facilitate use of the
             <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">
             RAII</a> pattern. For cases where RAII is not applicable, methods on SharedGroup
             allow for explicitly beginning and ending transactions, see
             {@link g_shared_group_begin_write} and {@link g_shared_group_begin_read}.

SEE        :
EXAMPLES:
- DESCR    :
  CODE     : ex_shared_group_intro
IGNORE     : []
CATEGORIES:
- Constructor:
  METHODS:
  - g_shared_group_constructor:
      NAMES    : SharedGroup
      SUMMARY  : &g_shared_group_constructor_summary
                 Create a shared group.
      DESCR    :
      - TEXT   : &g_shared_group_constructor_descr
                 >
                 Open a shared group (database will be created if it does not already exist).
                 Opening a shared group also creates a lock file in the same
                 directory as the database file. The lock file is used for cross-process
                 coordination of database access. The lock file is removed when
                 the last shared group is removed (but see below).

                 When multiple threads or processes access the same database file
                 through shared groups, each shared group must be opened in the same
                 durability mode.

      - TEXT   : &g_shared_group_durability_modes
                 >
                 By default the shared group will be fully durable, so that
                 each commit writes its changes to disk in an atomic manner
                 that guarantees that the file is always consistent.
                 The transaction will complete when the write has been done
                 to disk (depending on your disk, it might return when the
                 disk has received the data to it's cache).

                 You can also set the durability level to Asynchroneous.
                 This means that the actual write to disk can occur with a delay.
                 This provides much higher write performance, compared to full
                 durability. The transactions are still done atomically.
                 (Note: this mode is currently not implemented on Windows versions
                 of Realm).

                 If your data is transient, and does not need to persist to disk
                 (like for caching or shared state between processes). You can
                 open the shared group in memory-only mode. Then the file will
                 just be used for identification and backing; it will be removed
                 when there are no more processes using it.

                 When used with asynchronous durability level, a process running
                 in the background (the "commit daemon") may continue to update
                 the database after the application has terminated. The lock file will
                 be removed and the commit daemon will terminate once the update is
                 complete. As long as the lock file is present, new shared
                 groups can only be created with asynchronous durability level.

                 In case of abnormal termination or a machine crash, the lock file
                 may be left in an inconsistent state. SharedGroup tries to detect
                 and remedy this problem when it is opened, but it is not possible
                 to safely handle all scenarios. If safety cannot be ensured,
                 SharedGroup will give up and throw a PresumablyStaleLockFile exception.
                 In this case, the stale lock file must be removed manually. In all
                 cases the database file itself will be in a consistent state, even though
                 updates still pending at the time of crash will be lost.

      - TEXT   : &g_shared_group_constructor_descr_unattached
                 >
                 A SharedGroup may also be constructed in an unattached
                 state (2). See {@link g_shared_group_open} and
                 {@link g_shared_group_is_attached} for more on this.
      ENUM_SIG :
      - SIG    : >
                 SharedGroup(const std::string& path, bool no_create = false,
                             DurabilityLevel dlevel = durability_Full);
      - SIG    : SharedGroup(unattached_tag);
      PARAMS:
      - NAME   : path
        TYPES  : const std::string&
        DESCR  : *g_open_filesystem_path_descr
      - NAME   : no_create
        TYPES  : bool
        DESCR  : &g_shared_group_constructor_parm2_descr
                 If set to <tt>true</tt>, util::File::NotFound will be thrown
                 if the file does not already exist.
      - NAME   : dlevel
        TYPES  : DurabilityLevel
        DESCR  : &g_shared_group_constructor_parm3_descr
                 Durability Level (durability_Full, durability_MemOnly,
                 durability_Async).
      RETURN:
        TYPES  : SharedGroup
        DESCR  : &g_shared_group_constructor_return1_descr
                 A shared group.
      THROWS:
      - EXCEPT : util::File::AccessError
        DESCR  : *g_group_constructor_memory_throws_descr
      - EXCEPT : util::File::PermissionDenied
        DESCR  : *g_group_exc_perm
      - EXCEPT : util::File::NotFound
        DESCR  : *g_group_exc_notfound
      - EXCEPT : util::File::Exists
        DESCR  : *g_group_exc_exists
      - EXCEPT : InvalidDatabase
        DESCR  : *g_group_exc_invalid_db
      - EXCEPT : &cpp_stale_lockfile_except
                 SharedGroup::PresumablyStaleLockFile
        DESCR  : &g_stale_lockfile_descr
                 A lock file exist, but it cannot be decided whether it is safe to use it or not.
                 Verify that the lock file is not in use, then delete it and try again.
      - EXCEPT : &cpp_lockfile_but_no_data_except
                 SharedGroup::LockFileButNoData
        DESCR  : &g_lockfile_but_no_data_descr
                 An active sharing scheme has been established with at least one other SharedGroup,
                 but for some reason the database file does not exist. It would be unsafe to create
                 a new database in this situation, so an exception is thrown instead.
      - EXCEPT : &cpp_runtime_error_except
                 std::runtime_error
        DESCR  : &g_runtime_error_descr
                 A serious error occurred.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_constructor
        DESCR  :



- Scoped Transactions:
  METHODS:
  - g_write_trans_begin_write:
      NAMES    : WriteTransaction
      SUMMARY  : &g_write_trans_begin_write_summary
                 Create a write transaction.
      DESCR    : &g_write_trans_begin_write_descr
                 >
                 Create an object of type WriteTransaction. These objects provide
                 <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">
                 RAII</a> for write
                 transactions. Write transactions are committed by calling
                 {@link g_write_trans_commit}. If a write transaction goes out of scope without
                 calling commit, it is rolled back.
      PARAMS:
      - NAME   : sg
        TYPES  : SharedGroup&
        DESCR  : The shared group with which the transaction belongs.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_writetrans
        DESCR  :

  - g_read_trans_begin_read:
      NAMES    : ReadTransaction
      SUMMARY  : &g_read_trans_begin_read_summary
                 Create a read transaction.
      DESCR    : &g_read_trans_begin_read_descr
                 Create an object of type ReadTransaction. These objects provide
                 <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">
                 RAII</a> for read transactions.
      SIGNATURE: ReadTransaction(SharedGroup& sg)
      PARAMS:
      - NAME   : sg
        TYPES  : SharedGroup&
        DESCR  : The shared group with which the transaction belongs.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_readtrans
        DESCR  :

  - g_write_trans_commit:
      NAMES    : commit
      SUMMARY  : &g_shared_group_commit_summary
                 Commit a write transaction.
      DESCR    : &g_shared_group_commit_descr
                 This method closes a write transaction and all changes become visible to subsequent
                 transactions. If opened in full durability mode, commit only returns when the
                 changes have been committed to the database file. If opened in asynchronous
                 mode, the actual synchronization of the database file is delayed.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_writetrans
        DESCR  :

  - g_trans_get_table:
      NAMES    : get_table
      SUMMARY  : Get table from name.
      DESCR    : Given a name, find and return a reference to a table with that name.
      PARAMS:
      - NAME   : name
        TYPES  : StringData
        DESCR  : Name of a table.
      RETURN:
        TYPES  : TableRef
        DESCR  : A reference to a table.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_get_table
        DESCR  :

  - g_trans_get_group:
      NAMES    : get_group
      SUMMARY  : Get the group.
      DESCR    : Return the group used by the transaction. Take care not to call commit()
                 on the group.
      RETURN:
        TYPES  : Group&
        DESCR  : A group.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_get_group
        DESCR  :



- Transactions:
  METHODS:
  - g_shared_group_begin_write:
      NAMES    : begin_write
      SUMMARY  : &g_shared_group_begin_write_summary
                 Initiate write transaction.
      DESCR    : &g_shared_group_begin_write_descr
                 >
                 Initiate write transaction. Write transactions are serialized - only one write
                 transaction can progress at a time. Write transactions must be terminated by either
                 {@link g_shared_group_commit} or {@link g_shared_group_rollback}.

                 Using a scoped write transaction and the RAII pattern should be preferred over direct use of
                 begin_write whenever possible, as it leads to cleaner code. See {@link g_write_trans_begin_write}
                 for an example.
      RETURN:
        TYPES  : Group&
        DESCR  : &g_shared_group_begin_write_return1_descr
                 A group.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_write
        DESCR  :

  - g_shared_group_commit:
      NAMES    : commit
      SUMMARY  : *g_shared_group_commit_summary
      DESCR    : *g_shared_group_commit_descr
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_write
        DESCR  :

  - g_shared_group_rollback:
      NAMES    : rollback
      SUMMARY  : &g_shared_group_rollback_summary
                 Rollback a write transaction.
      DESCR    : &g_shared_group_rollback_descr
                 This method closes a transaction and discards all changes done to the shared group,
                 unless a commit has already been done. It is ok to call rollback multiple times.
                 Any additional calls to rollback following a commit or rollback are treated as no-ops.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_write
        DESCR  :

  - g_shared_group_begin_read:
      NAMES    : begin_read
      SUMMARY  : &g_shared_group_begin_read_summary
                 Initiate read transaction.
      DESCR    : &g_shared_group_begin_read_descr
                 >
                 Initiate read transaction. During the read transaction,
                 you have a fully consistent immutable view of the group.
                 You must call {@link g_shared_group_end_read} to terminate the transaction.

                 Creating a scoped read transaction should be preferred over direct use of
                 begin_read whenever possible, as it leads to cleaner code. See {@link g_read_trans_begin_read}
                 for an example
      CONST    : True
      RETURN:
        TYPES  : Group&
        DESCR  : A group.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_read
        DESCR  :

  - g_shared_group_end_read:
      NAMES    : end_read
      SUMMARY  : &g_shared_group_end_read_summary
                 Terminate read transaction.
      DESCR    : &g_shared_group_end_read_descr
                 This method terminates a read transaction which was started with
                 {@link g_shared_group_begin_read}.
                 It is ok to call end_read multiple times, the first call will terminate the transaction.
                 Any additional calls are treated as no-ops.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_read
        DESCR  :


- Utilities:
  METHODS:
  - g_shared_group_open:
      NAMES    : open
      SUMMARY  : &g_shared_group_open_summary
                 Attach this SharedGroup to a file.
      SIGNATURE: >
                 open(const std::string& file, bool no_create = false, DurabilityLevel dlevel = durability_Full)
      DESCR    : &g_shared_group_open_descr
       - TEXT  :
                 >
                 Attach this SharedGroup instance to the specified
                 database file.

                 If the database file does not already exist, it will
                 be created (unless <tt>no_create</tt> is set to
                 true.)

       - TEXT  : *g_shared_group_durability_modes

       - TEXT  : Calling open() on a SharedGroup instance that is
                 already in the attached state has undefined behavior.
      PARAMS:
      - NAME   : path
        TYPES  : const std::string&
        DESCR  : *g_open_filesystem_path_descr
      - NAME   : no_create
        TYPES  : bool
        DESCR  : &g_shared_group_open_parm2_descr
                 If set to <tt>true</tt>, util::File::NotFound will be thrown
                 if the file does not already exist.
      - NAME   : dlevel
        TYPES  : DurabilityLevel
        DESCR  : &g_shared_group_open_parm3_descr
                 Durability Level (durability_Full or durability_MemOnly).
      THROWS:
      - EXCEPT : util::File::AccessError
        DESCR  : *g_group_constructor_memory_throws_descr
      - EXCEPT : util::File::PermissionDenied
        DESCR  : *g_group_exc_perm
      - EXCEPT : util::File::NotFound
        DESCR  : *g_group_exc_notfound
      - EXCEPT : util::File::Exists
        DESCR  : *g_group_exc_exists
      - EXCEPT : InvalidDatabase
        DESCR  : *g_group_exc_invalid_db
      - EXCEPT : *cpp_stale_lockfile_except
        DESCR  : *g_stale_lockfile_descr
      - EXCEPT : *cpp_lockfile_but_no_data_except
        DESCR  : *g_lockfile_but_no_data_descr
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_shared_group_open

  - g_shared_group_is_attached:
      NAMES    : is_attached
      SUMMARY  : &g_shared_group_is_attached_summary
                 Is this SharedGroup instance in its attached state?
      DESCR    : &g_shared_group_is_attached_descr
                 A shared group may be created in the unattached
                 state, and then later attached to a file with a call
                 to one of the open() methods. Calling any method
                 other than open(), is_attached(), and ~SharedGroup()
                 on an unattached instance results in undefined
                 behavior.
      CONST    : true
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if attached, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_shared_group_is_attached

  - g_shared_group_reserve:
      NAMES    : reserve
      SUMMARY  : &g_shared_group_reserve_summary
                 Reserve disk space.
      DESCR    : &g_shared_group_reserve_descr
                 Reserve disk space now to avoid allocation errors at
                 a later point in time, and to minimize on-disk
                 fragmentation. In some cases, less fragmentation
                 translates into improved performance.

                 When supported by the system, a call to this function
                 will make the database file at least as big as the
                 specified size, and cause space on the target device
                 to be allocated (note that on many systems on-disk
                 allocation is done lazily by default). If the file is
                 already bigger than the specified size, the size will
                 be unchanged, and on-disk allocation will occur only
                 for the initial section that corresponds to the
                 specified size. On systems that do not support
                 preallocation, this function has no effect. To know
                 whether preallocation is supported by Realm on your
                 platform, call util::File::is_prealloc_supported().

                 It is an error to call this function on an unattached
                 shared group. Doing so will result in undefined
                 behavior.
      PARAMS:
      - NAME   : size_in_bytes
        TYPES  : std::size_t
        DESCR  : &g_shared_group_reserve_parm1
                 The total number of bytes to reserve on disk for this database.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_shared_group_reserve

  - g_shared_group_has_changed:
      NAMES    : has_changed
      SUMMARY  : &g_shared_group_has_changed_summary
                 Has shared group been changed since last transaction?
      DESCR    : &g_shared_group_has_changed_descr
                 >
                 This method tests if the shared group has been modified (by another process),
                 since the last transaction.

                 It has very little overhead and does not affect other processes, so it is
                 ok to call it at regular intervals (like in the idle handler of an application).
      RETURN:
        TYPES  : bool
        DESCR  : &g_shared_group_has_changed_return
                 <code>true</code> if it has changed, <code>false</code> otherwise.
      EXAMPLES:
      - CODE   : ex_cpp_shared_group_has_changed
        DESCR  :



