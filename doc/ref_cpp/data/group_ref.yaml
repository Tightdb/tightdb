#
# C++ reference documentation for Group class
#

#UNDOCUMENTED: [commit, to_json, get_table_typed]
ID         : class_group
TITLE      : Group
SUMMARY    : &g_group_summary
             Container for tables.
DESCR      : &g_group_descr
             >
             In order to store tables on disk or transfer tables over network, they must be
             serialized. The TightDB framework provides various methods including
             <a href="http://www.json.org">JSON</a> for single tables.

             The Group is a container for tables and it allows the tables to be serialized to
             disk and memory. The serialization format is highly optimized for TightDB tables,
             which implies that the consumed resources are low.

             A group can hold one or more tables. If a table is going to be serialized, you
             must create the table using the group. It is not possible to dynamically add a table
             to a group.

             Once a group has been serialized, it is possible to deserialize it using any supported
             programming language, at any supported operating system and at any supported
             hardware platform. This implies that the TightDB framework is true a polyglot
             framework where you can share data between applications.
SEE        :
EXAMPLES:
- DESCR    :
  CODE     : ex_cpp_group_intro
IGNORE     : []                   # List of method-ids to ignore
CATEGORIES:
- Constructor:
  METHODS:
  - g_group_constructor_plain:
  - g_group_constructor_file:
  - g_group_constructor_memory:
      NAMES    : Group
      DESCR    : &g_group_constructor_descr
                 >
                 Group objects can be created in various ways
                 depending on use pattern.

                 You can either just create a new (empty) group, or load an
                 existing group either from a file or memory buffer.

                 A group may also be constructed in an unattached
                 state (4). See open() and is_attached() for more on
                 this.

      SUMMARY  : &g_group_constructor_summary
                 Creates a table group.
      SIGNATURE: |
                 Group();
                 Group(const std::string& file, OpenMode mode = mode_Normal);
                 Group(BufferSpec buffer, bool take_ownership = true);
                 Group(unattached_tag) noexcept;
      PARAMS:
      - NAME   : file
        TYPES  : const std::string&
        DESCR  : Filesystem path of the TightDB database file to be opened.
      - NAME   : mode
        TYPES  : Group::OpenMode
        DESCR  : |
                 Group::mode_Normal:   Open in read/write mode, create the file if it does not already exist.
                 Group::mode_ReadOnly: Open in read-only mode, fail if the file does not already exist.
                 Group::mode_NoCreate: Open in read/write mode, fail if the file does not already exist.
      - NAME   : buffer
        TYPES  : Group::BufferSpec
        DESCR  : In-memory binary encoded representation of a group.
      - NAME   : len
        TYPES  : std::size_t
        DESCR  : Size of the representation.
      RETURN:
        TYPES  : Group
        DESCR  : A - possibly empty - group.
      THROWS:
      - EXCEPT : File::OpenError
        DESCR  : If the file (or buffer) could not be opened. If the reason
                 corresponds to one of the exception types that are
                 derived from File::OpenError, the derived exception
                 type is thrown. Note that InvalidDatabase is among
                 these derived exception types.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_constructor_plain
      - DESCR  :
        CODE   : ex_cpp_group_constructor_file
      - DESCR  :
        CODE   : ex_cpp_group_constructor_memory
- Operators:
  METHODS:
  - g_group_operator_equal:
      NAMES    : operator==
      DESCR    : &g_group_operator_equal_descr
                 >
                 Compare two groups for equality. Two groups are equal if, and
                 only if, they contain the same tables in the same order, that
                 is, for each table T at index I in one of the groups, there is
                 a table at index I in the other group that is equal to T.
      SUMMARY  : Compare two groups.
      CONST    : true
      PARAMS:
      - TYPES  : const Group&
        NAME   : g
        DESCR  : The group to compare with.
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if the two groups are equal, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_operator_equal
  - g_group_operator_not_equal:
      NAMES    : operator!=
      DESCR    : *g_group_operator_equal_descr
      SUMMARY  : Compare two groups.
      CONST    : true
      PARAMS:
      - TYPES  : const Group&
        NAME   : g
        DESCR  : The group to compare with.
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if the two groups are not equal, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_operator_equal
- Table:
  METHODS:
  - g_group_table_count:
      NAMES    : get_table_count
      DESCR    : >
                 A group can be a container for many tables, and this method counts
                 the number of tables currently stored in the group.
      SUMMARY  : The number of tables in the group.
      CONST    : true
      RETURN:
        TYPES  : size_t
        DESCR  : The number of tables.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_traverse
  - g_group_get_table:
      NAMES    : get_table
      SUMMARY  : &g_group_get_table_summary
                 Get a table.
      DESCR    : &g_group_get_table_descr
                 >
                 This method will find and return a named table.

                 When no table class is specified, this function
                 returns a dynamically typed table accessor. When a
                 table class (<code>MyTable</code>) is specified as a
                 template parameter, you get a statically typed table
                 accessor.

                 It is an error to specify unmatching table class for
                 an existing table in the group. Doing so will
                 result in undefined behaviour. For this reason you
                 should generally never call
                 <code>get_table<MyTable>()</code>
                 without first checking the type of the table with a
                 call to <code>has_table<MyTable>()</code>.

                 If no table exists with the specified name, a new
                 empty table will be created.
      SIGNATURE: |
                 TableRef          get_table(const char* name);
                 ConstTableRef     get_table(const char* name) const;
                 MyTable::Ref      get_table<MyTable>(const char* name);
                 MyTable::ConstRef get_table<MyTable>(const char* name) const;
      PARAMS:
      - NAME   : name
        TYPES  : const char*
        DESCR  : >
                 Name of the table you wish to retrieve.
      - NAME   : tableclass
        TYPES  : class definition
        DESCR  : Typed table class.
      RETURN:
        TYPES  : [TableRef, ConstTableRef]
        DESCR  : A table reference object.
      EXAMPLES:
      -  DESCR :
         CODE  : ex_cpp_group_traverse
      -  DESCR :
         CODE  : ex_cpp_group_optional_table
      SEE      : "{@link g_group_has_table}"
  - g_group_has_table:
      NAMES    : has_table
      CONST    : true
      SUMMARY  : &g_group_has_table_summary
                 Does group have table?
      DESCR    : &g_group_has_table_descr
                 >
                 The method checks whether this group contains
                 the specified table.

                 When no table class is specified, this function
                 returns <code>true</code> if the group contains a
                 table with the
                 specified name. When a table class
                 (<code>MyTable</code>) is specified as a template
                 parameter, it returns true if the group contains a
                 table with the specified name, and the type of that
                 table is compatible with the specified type. See
                 {@link concepts_table_type_compatibility} for details.
      PARAMS:
      - NAME   : name
        TYPES  : const char*
        DESCR  : Name of the table you wish to look for.
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if the table exits, otherwise <code>false</code>.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_optional_table
  - g_group_get_table_name:
      NAMES    : get_table_name
      DESCR    : This method will find the name of a table stored in the group.
      SUMMARY  : Get the name of a table.
      CONST    : true
      PARAMS:
      - NAME   : table_ndx
        TYPES  : size_t
        DESCR  : Table index.
      RETURN:
        TYPES  : const char*
        DESCR  : The table name.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_traverse
- IO:
  METHODS:
  - g_group_write_to_file:
      NAMES    : write
      SUMMARY  : &g_group_write_to_file_summary
                 Write a group to disk.
      DESCR    : &g_group_write_to_file_descr
                 This method will write the group to persistent storage (disk). Metadata and tables
                 will be stored, and can be retrieved at later times.
      PARAMS:
      - NAME   : file
        TYPES  : const std::string&
        DESCR  : A filesystem path.
      THROWS:
      - EXCEPT : File::OpenError
        DESCR  : If the file could not be opened. If the reason
                 corresponds to one of the exception types that are
                 derived from File::OpenError, the derived exception
                 type is thrown.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_write_to_file
  - g_group_write_to_mem:
      NAMES    : write_to_mem
      SUMMARY  : &g_group_write_to_mem_summary
                 Write a group to an in-memory buffer.
      DESCR    : &g_group_write_to_mem_descr
                 This method will write the group to an in-memory buffer. This may be useful if you
                 want to transfer a group over a TCP connection. The returned buffer will have been
                 allocated using std::malloc(). The ownership of the buffer is passed to the caller.
      RETURN:
        DESCR  : The allocated buffer. You will have to call std::free() when you are done with it.
        TYPES  : Group::BufferSpec
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_write_to_mem
- Group:
  METHODS:
  - g_group_is_empty:
      NAMES    : is_empty
      SUMMARY  : &g_group_is_empty_summary
                 Is group empty?
      DESCR    : &g_group_is_empty_descr
                 This method checks if group is empty that is, does it have zero tables.
      CONST    : true
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if group is empty, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_is_empty
  - g_group_tostring:
      NAMES    : to_string
      SUMMARY  : &g_group_to_string_summary
                 Get a string representation of the group.
      DESCR    : &g_group_to_string_descr
                 This methods adds a string representation of information about the group to an
                 output stream.
      CONST    : true
      PARAMS:
      - NAME   : out
        TYPES  : std::ostream&
        DESCR  : The output stream.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_tostring
  - g_group_open_file:
  - g_group_open_memory:
      NAMES    : open
      DESCR    : &g_group_open_descr
                 >
                 Attach this Group instance to a file or an externally
                 supplied memory buffer.

                 If the specified file exists in the file system, it
                 must contain a valid TightDB database. If the file
                 does not exist, it will be created (unless
                 mode_NoCreate is specified). While a group
                 constructed this way, can be used to access and
                 manipulate a TightDB database, it is generally better
                 to use a SharedGroup instance along with proper
                 transactions.

                 Changes made to the database via a Group instance are
                 not automatically committed to the specified
                 file. You may, however, at any time, explicitely
                 commit your changes by calling the commit()
                 method. Alternatively you may call write() to write
                 the entire database to a new file.

                 Specifying a memory buffer is equivalent to
                 specifying a file except that in this case the
                 database is assumed to be stored in that buffer.

                 If <tt>take_ownership</tt> is <tt>true</tt>, you will
                 pass the ownership of the specified buffer to the
                 Group instance. In this case the buffer will
                 eventually be freed using std::free(), so the buffer
                 you pass, must have been allocated using
                 std::malloc().

                 On the other hand, if <tt>take_ownership</tt> is set
                 to <tt>false</tt>, it is your responsibility to keep
                 the memory buffer alive during the lifetime of the
                 group, and in case the buffer needs to be deallocated
                 afterwards, that is your responsibility too.

                 Calling open() on a Group instance that is already in
                 the attached state has undefined behavior.

      SUMMARY  : &g_group_open_summary
                 Attach to a file or a memory buffer.
      SIGNATURE: |
                 void open(const std::string& file, OpenMode mode = mode_Normal);
                 void open(BufferSpec buffer, bool take_ownership = true);
      PARAMS:
      - NAME   : file
        TYPES  : const std::string&
        DESCR  : Filesytem path of the TightDB database file to be opened.
      - NAME   : mode
        TYPES  : Group::OpenMode
        DESCR  : See Group().
      - NAME   : buffer
        TYPES  : Group::BufferSpec
        DESCR  : In-memory binary encoded representation of a group.
      - NAME   : len
        TYPES  : std::size_t
        DESCR  : Size of the representation.
      THROWS:
      - EXCEPT : File::OpenError
        DESCR  : If the file (or buffer) could not be opened. If the reason
                 corresponds to one of the exception types that are
                 derived from File::OpenError, the derived exception
                 type is thrown. Note that InvalidDatabase is among
                 these derived exception types.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_open_file
      - DESCR  :
        CODE   : ex_cpp_group_open_memory
  - g_group_is_attached:
      NAMES    : is_attached
      SUMMARY  : &g_group_is_attached_summary
                 Is this Group instance in its attached state?
      DESCR    : &g_group_is_attached_descr
                 A group may be created in the unattached state, and
                 then later attached to a file or a memory buffer with
                 a call to one of the open() methods. Calling any
                 method other than open(), is_attached(), and ~Group()
                 on an unattached instance results in undefined
                 behavior.
      CONST    : true
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if attached, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_is_attached
